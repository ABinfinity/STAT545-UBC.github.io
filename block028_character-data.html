<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Character data</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68219208-1', 'auto');
  ga('send', 'pageview');

</script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="libs/highlight/default.css"
      type="text/css" />
<script src="libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="libs/local/main.css" type="text/css" />
<link rel="stylesheet" href="libs/local/nav.css" type="text/css" />
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script src="libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->





<header>
  <div class="nav">
    <a class="nav-logo" href="index.html">
      <img src="static/img/stat545-logo-s.png" width="70px" height="70px"/>
    </a>
    <ul>
      <li class="home"><a href="index.html">Home</a></li>
      <li class="faq"><a href="faq.html">FAQ</a></li>
      <li class="syllabus"><a href="syllabus.html">Syllabus</a></li>
      <li class="topics"><a href="topics.html">Topics</a></li>
      <li class="people"><a href="people.html">People</a></li>
    </ul>
  </div>
</header>

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Character data</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#character-vectors-where-they-fit-in">Character vectors: where they fit in</a></li>
<li><a href="#resources">Resources</a></li>
<li><a href="#load-stringr-and-the-core-tidyverse">Load stringr and the core tidyverse</a></li>
<li><a href="#basic-string-manipulation-with-stringr-and-tidyr">Basic string manipulation with stringr and tidyr</a><ul>
<li><a href="#detect-or-filter-on-a-target-string">Detect or filter on a target string</a></li>
<li><a href="#string-splitting-by-pattern">String splitting by pattern</a></li>
<li><a href="#substring-extraction-and-replacement-by-position">Substring extraction (and replacement) by position</a></li>
<li><a href="#collapse-a-vector">Collapse a vector</a></li>
<li><a href="#create-a-character-vector-by-catenating-multiple-vectors">Create a character vector by catenating multiple vectors</a></li>
<li><a href="#substring-replacement">Substring replacement</a></li>
</ul></li>
<li><a href="#regular-expression-with-stringr">Regular expression with stringr</a><ul>
<li><a href="#load-gapminder">Load Gapminder</a></li>
<li><a href="#characters-with-special-meaning">Characters with special meaning</a></li>
<li><a href="#character-classes">Character classes</a></li>
<li><a href="#quantifiers">Quantifiers</a></li>
<li><a href="#escaping">Escaping</a></li>
<li><a href="#backreferences">Backreferences</a></li>
</ul></li>
</ul>
</div>

<p><em>Under development</em></p>
<div id="character-vectors-where-they-fit-in" class="section level3">
<h3>Character vectors: where they fit in</h3>
<p>We’ve spent alot of time working with big, beautiful data frames. That are clean and wholesome, like the Gapminder data.</p>
<p>But real life will be much nastier. You will bring data into R from the outside world and discover there are problems. You might think: how hard can it be to deal with character data? And the answer is: it can be very hard!</p>
<ul>
<li><a href="http://stackstatus.net/post/147710624694/outage-postmortem-july-20-2016">Stack Exchange outage</a></li>
<li><a href="http://emailregex.com">Regexes to validate/match email addresses</a></li>
<li><a href="http://davidvgalbraith.com/how-i-fixed-atom/">Fixing an Atom bug</a></li>
</ul>
<p>Here we discuss common remedial tasks for cleaning and transforming character data, also known as “strings”. A data frame or tibble will consist of one or more <em>atomic vectors</em> of a certain class. This lesson deals with things you can do with vectors of class <code>character</code>.</p>
</div>
<div id="resources" class="section level3">
<h3>Resources</h3>
<p>I start with this because we cannot possibly do this topic justice in a short amount of time. Our goal is to make you aware of broad classes of problems and their respective solutions. Once you have a character problem in real life, these resources will be extremely helpful as you delve deeper.</p>
<p>Manipulating character vectors</p>
<ul>
<li><a href="https://cran.r-project.org/web/packages/stringr/index.html">stringr package</a>
<ul>
<li>A non-core package in the tidyverse. It is installed via <code>install.packages(&quot;tidyverse&quot;)</code>, but not loaded via <code>library(tidyverse)</code>. Load it as needed via <code>library(stringr)</code>.</li>
<li>Main functions start with <code>str_</code>. Auto-complete is your friend.</li>
<li>Replacements for base functions re: string manipulation and regular expressions (see below).</li>
<li>Main advantage over base functions: greater consistency about inputs and outputs. Outputs are more ready for your next analytical task.</li>
<li>Wraps <a href="https://cran.r-project.org/web/packages/stringi/index.html">stringi</a>, which is a great place to look if stringr isn’t powerful enough.</li>
</ul></li>
<li><a href="https://cran.r-project.org/web/packages/tidyr/index.html">tidyr package</a>
<ul>
<li>Especially useful for functions that split 1 character vector into many and <em>vice versa</em>: <code>separate()</code>, <code>unite()</code>, <code>extract()</code>.</li>
</ul></li>
<li>Base functions: <code>nchar()</code>, <code>strsplit()</code>, <code>substr()</code>, <code>paste()</code>, <code>paste0()</code>.</li>
</ul>
<p>Regular expressions: a God-awful and powerful language for expressing patterns to match in text or for search-and-replace. Frequently described as “write only”, because regular expressions are easier to write than to read/understand. And they are not particularly easy to write.</p>
<ul>
<li>The <a href="http://r4ds.had.co.nz/strings.html">Strings chapter</a> of <a href="http://r4ds.had.co.nz">R for Data Science</a> is excellent.</li>
<li>STAT 545 lessons on regular expressions:
<ul>
<li><a href="block022_regular-expression.html">2014 Intro to regular expressions</a> by TA Gloria Li.</li>
<li><a href="block027_regular-expressions.html">2015 Regular expressions and character data in R</a> by TA Kieran Samuk.</li>
<li>Excellent content in both. Why am I redeveloping, then? To be more consistent re: using stringr and to use examples whose availability is easier for me to support long-term.</li>
</ul></li>
<li>RStudio Cheat Sheet on <a href="https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf">Regular Expressions in R</a></li>
<li>Regex testers
<ul>
<li><a href="https://regex101.com">regex101.com</a></li>
<li><a href="http://regexr.com">regexr.com</a></li>
</ul></li>
<li><a href="https://github.com/kevinushey/rex">rex R package</a>: make regular expression from human readable expressions</li>
</ul>
<div class="figure">
<img src="img/regexbytrialanderror-big-smaller.png" />

</div>
<p>Encoding</p>
<ul>
<li><a href="http://r4ds.had.co.nz/data-import.html#readr-strings">Strings subsection of data import chapter</a> in R for Data Science</li>
<li>Screeds on the Minimum Everyone Needs to Know about encoding
<ul>
<li><a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></li>
<li><a href="http://kunststube.net/encoding/">What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text</a></li>
</ul></li>
<li><a href="http://www.justinweiss.com/articles/3-steps-to-fix-encoding-problems-in-ruby/">Guide to fixing encoding problems in Ruby</a> <em>parking here temporariliy … looks useful but, obviously, it’s about Ruby not R</em></li>
</ul>
<p>Manipulating character vectors that live in a data frame</p>
<ul>
<li>Certain operations are facilitated by <code>tidyr</code>. These are described below.</li>
<li>For a general discussion of how to work on variables that live in a data frame, see <a href="block031_vector-tibble-relations.html">Vectors versus tibbles</a></li>
</ul>
</div>
<div id="load-stringr-and-the-core-tidyverse" class="section level3">
<h3>Load stringr and the core tidyverse</h3>
<pre class="r"><code>library(tidyverse)
#&gt; Loading tidyverse: ggplot2
#&gt; Loading tidyverse: tibble
#&gt; Loading tidyverse: tidyr
#&gt; Loading tidyverse: readr
#&gt; Loading tidyverse: purrr
#&gt; Loading tidyverse: dplyr
#&gt; Conflicts with tidy packages ----------------------------------------------
#&gt; filter(): dplyr, stats
#&gt; lag():    dplyr, stats
library(stringr)</code></pre>
</div>
<div id="basic-string-manipulation-with-stringr-and-tidyr" class="section level3">
<h3>Basic string manipulation with stringr and tidyr</h3>
<p>Basic string manipulation tasks:</p>
<ul>
<li>Study a single character vector
<ul>
<li>How long are the strings?</li>
<li>Presence/absence of a literal string</li>
</ul></li>
<li>Operate on a single character vector
<ul>
<li>Keep/discard elements that contain a literal string</li>
<li>Split into two or more character vectors using a fixed delimiter<br />
</li>
<li>Snip out pieces of the strings based on character position</li>
<li>Collapse into a single string</li>
</ul></li>
<li>Operate on two or more character vectors
<ul>
<li>Glue them together element-wise to get a new character vector.</li>
</ul></li>
</ul>
<p><em><code>fruit</code>, <code>words</code>, and <code>sentences</code> are character vectors that ship with <code>stringr</code> for practicing.</em></p>
<div id="detect-or-filter-on-a-target-string" class="section level4">
<h4>Detect or filter on a target string</h4>
<p>Determine presence/absence of a literal string with <code>str_detect()</code>. Spoiler: later we see <code>str_detect()</code> also detects regular expressions.</p>
<p>Which fruits actually use the word “fruit”?</p>
<pre class="r"><code>str_detect(fruit, &quot;fruit&quot;)
#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
#&gt; [12]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
#&gt; [23] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
#&gt; [34] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE
#&gt; [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
#&gt; [56] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
#&gt; [67] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
#&gt; [78] FALSE  TRUE FALSE</code></pre>
<p>What’s the easiest way to get the actual fruits that match? Use <code>str_subset()</code> to keep only the matching elements. Note we are storing this new vector <code>my_fruit</code> to use in later examples!</p>
<pre class="r"><code>(my_fruit &lt;- str_subset(fruit, &quot;fruit&quot;))
#&gt; [1] &quot;breadfruit&quot;   &quot;dragonfruit&quot;  &quot;grapefruit&quot;   &quot;jackfruit&quot;   
#&gt; [5] &quot;kiwi fruit&quot;   &quot;passionfruit&quot; &quot;star fruit&quot;   &quot;ugli fruit&quot;</code></pre>
</div>
<div id="string-splitting-by-pattern" class="section level4">
<h4>String splitting by pattern</h4>
<p>Use <code>stringr::str_split()</code> to split strings on a delimiter. Some of our fruits are compound words, like “grapefruit”, but some have two words, like “ugli fruit”. Here we split on a single space <code>&quot; &quot;</code>, but show use of a regular expression later.</p>
<pre class="r"><code>str_split(my_fruit, &quot; &quot;)
#&gt; [[1]]
#&gt; [1] &quot;breadfruit&quot;
#&gt; 
#&gt; [[2]]
#&gt; [1] &quot;dragonfruit&quot;
#&gt; 
#&gt; [[3]]
#&gt; [1] &quot;grapefruit&quot;
#&gt; 
#&gt; [[4]]
#&gt; [1] &quot;jackfruit&quot;
#&gt; 
#&gt; [[5]]
#&gt; [1] &quot;kiwi&quot;  &quot;fruit&quot;
#&gt; 
#&gt; [[6]]
#&gt; [1] &quot;passionfruit&quot;
#&gt; 
#&gt; [[7]]
#&gt; [1] &quot;star&quot;  &quot;fruit&quot;
#&gt; 
#&gt; [[8]]
#&gt; [1] &quot;ugli&quot;  &quot;fruit&quot;</code></pre>
<p>It’s bummer that we get a <em>list</em> back. But it must be so! In full generality, split strings must return list, because who knows how many pieces there will be?</p>
<p>If you are willing to commit to the number of pieces, you can use <code>str_split_fixed()</code> and get a character matrix. You’re welcome!</p>
<pre class="r"><code>str_split_fixed(my_fruit, &quot; &quot;, n = 2)
#&gt;      [,1]           [,2]   
#&gt; [1,] &quot;breadfruit&quot;   &quot;&quot;     
#&gt; [2,] &quot;dragonfruit&quot;  &quot;&quot;     
#&gt; [3,] &quot;grapefruit&quot;   &quot;&quot;     
#&gt; [4,] &quot;jackfruit&quot;    &quot;&quot;     
#&gt; [5,] &quot;kiwi&quot;         &quot;fruit&quot;
#&gt; [6,] &quot;passionfruit&quot; &quot;&quot;     
#&gt; [7,] &quot;star&quot;         &quot;fruit&quot;
#&gt; [8,] &quot;ugli&quot;         &quot;fruit&quot;</code></pre>
<p>If the to-be-split variable lives in a data frame, <code>tidyr::separate()</code> will split it into 2 or more variables.</p>
<pre class="r"><code>my_fruit_df &lt;- tibble(my_fruit)
my_fruit_df %&gt;% 
  separate(my_fruit, into = c(&quot;pre&quot;, &quot;post&quot;), sep = &quot; &quot;)
#&gt; Warning: Too few values at 5 locations: 1, 2, 3, 4, 6
#&gt; # A tibble: 8 × 2
#&gt;            pre  post
#&gt; *        &lt;chr&gt; &lt;chr&gt;
#&gt; 1   breadfruit  &lt;NA&gt;
#&gt; 2  dragonfruit  &lt;NA&gt;
#&gt; 3   grapefruit  &lt;NA&gt;
#&gt; 4    jackfruit  &lt;NA&gt;
#&gt; 5         kiwi fruit
#&gt; 6 passionfruit  &lt;NA&gt;
#&gt; 7         star fruit
#&gt; 8         ugli fruit</code></pre>
</div>
<div id="substring-extraction-and-replacement-by-position" class="section level4">
<h4>Substring extraction (and replacement) by position</h4>
<p>Count characters in your strings with <code>str_length()</code>. Note this is different from the length of the character vector itself.</p>
<pre class="r"><code>length(my_fruit)
#&gt; [1] 8
str_length(my_fruit)
#&gt; [1] 10 11 10  9 10 12 10 10</code></pre>
<p>You can snip out substrings based on character position with <code>str_sub()</code>.</p>
<pre class="r"><code>head(fruit) %&gt;% 
  str_sub(1, 3)
#&gt; [1] &quot;app&quot; &quot;apr&quot; &quot;avo&quot; &quot;ban&quot; &quot;bel&quot; &quot;bil&quot;</code></pre>
<p>The <code>start</code> and <code>end</code> arguments are vectorised. Example: a sliding 3-character window.</p>
<pre class="r"><code>tibble(fruit) %&gt;% 
  head() %&gt;% 
  mutate(snip = str_sub(fruit, 1:6, 3:8))
#&gt; # A tibble: 6 × 2
#&gt;         fruit  snip
#&gt;         &lt;chr&gt; &lt;chr&gt;
#&gt; 1       apple   app
#&gt; 2     apricot   pri
#&gt; 3     avocado   oca
#&gt; 4      banana   ana
#&gt; 5 bell pepper    pe
#&gt; 6    bilberry   rry</code></pre>
<p>Finally, <code>str_sub()</code> also works for assignment, i.e. on the left hand side of <code>&lt;-</code>.</p>
<pre class="r"><code>x &lt;- head(fruit, 3)
str_sub(x, 1, 3) &lt;- &quot;AAA&quot;
x
#&gt; [1] &quot;AAAle&quot;   &quot;AAAicot&quot; &quot;AAAcado&quot;</code></pre>
</div>
<div id="collapse-a-vector" class="section level4">
<h4>Collapse a vector</h4>
<p>You can collapse a character of length <code>n &gt; 1</code> to a single string with <code>str_c()</code>, which also has other uses (see next section).</p>
<pre class="r"><code>head(fruit) %&gt;% 
  str_c(collapse = &quot;, &quot;)
#&gt; [1] &quot;apple, apricot, avocado, banana, bell pepper, bilberry&quot;</code></pre>
</div>
<div id="create-a-character-vector-by-catenating-multiple-vectors" class="section level4">
<h4>Create a character vector by catenating multiple vectors</h4>
<p>If you have two or more character vectors of the same length, you can glue them together element-wise, to get a new vector of that length. Here are some … awful smoothie flavors?</p>
<pre class="r"><code>str_c(fruit[1:4], fruit[5:8], sep = &quot; &amp; &quot;)
#&gt; [1] &quot;apple &amp; bell pepper&quot;   &quot;apricot &amp; bilberry&quot;    &quot;avocado &amp; blackberry&quot; 
#&gt; [4] &quot;banana &amp; blackcurrant&quot;</code></pre>
<p>Element-wise catenation can be combined with collapsing.</p>
<pre class="r"><code>str_c(fruit[1:4], fruit[5:8], sep = &quot; &amp; &quot;, collapse = &quot;, &quot;)
#&gt; [1] &quot;apple &amp; bell pepper, apricot &amp; bilberry, avocado &amp; blackberry, banana &amp; blackcurrant&quot;</code></pre>
<p>If the to-be-combined vectors are variables in a data frame, you can use <code>tidyr::unite()</code> to make a single new variable from them</p>
<pre class="r"><code>fruit_df &lt;- tibble(fruit1 = fruit[1:4], fruit2 = fruit[5:8])
fruit_df %&gt;% 
  unite(&quot;flavor_combo&quot;, fruit1, fruit2, sep = &quot; &amp; &quot;)
#&gt; # A tibble: 4 × 1
#&gt;            flavor_combo
#&gt; *                 &lt;chr&gt;
#&gt; 1   apple &amp; bell pepper
#&gt; 2    apricot &amp; bilberry
#&gt; 3  avocado &amp; blackberry
#&gt; 4 banana &amp; blackcurrant</code></pre>
</div>
<div id="substring-replacement" class="section level4">
<h4>Substring replacement</h4>
<p>You can replace a pattern with <code>str_replace()</code>. Here we use an explicit string-to-replace, but later we revisit with a regular expression.</p>
<pre class="r"><code>str_replace(my_fruit, &quot;fruit&quot;, &quot;THINGY&quot;)
#&gt; [1] &quot;breadTHINGY&quot;   &quot;dragonTHINGY&quot;  &quot;grapeTHINGY&quot;   &quot;jackTHINGY&quot;   
#&gt; [5] &quot;kiwi THINGY&quot;   &quot;passionTHINGY&quot; &quot;star THINGY&quot;   &quot;ugli THINGY&quot;</code></pre>
<p>A special case that comes up alot is replacing <code>NA</code>, for which there is <code>str_replace_na()</code>.</p>
<pre class="r"><code>melons &lt;- str_subset(fruit, &quot;melon&quot;)
melons[2] &lt;- NA
melons
#&gt; [1] &quot;canary melon&quot; NA             &quot;watermelon&quot;
str_replace_na(melons, &quot;UNKNOWN MELON&quot;)
#&gt; [1] &quot;canary melon&quot;  &quot;UNKNOWN MELON&quot; &quot;watermelon&quot;</code></pre>
<p>If the <code>NA</code>-afflicted variable lives in a data frame, you can use <code>tidyr::replace_na()</code>.</p>
<pre class="r"><code>tibble(melons) %&gt;% 
  replace_na(replace = list(melons = &quot;UNKNOWN MELON&quot;))
#&gt; # A tibble: 3 × 1
#&gt;          melons
#&gt;           &lt;chr&gt;
#&gt; 1  canary melon
#&gt; 2 UNKNOWN MELON
#&gt; 3    watermelon</code></pre>
<p>And that concludes our treatment of regex-free manipulations of character data!</p>
</div>
</div>
<div id="regular-expression-with-stringr" class="section level3">
<h3>Regular expression with stringr</h3>
<div id="load-gapminder" class="section level4">
<h4>Load Gapminder</h4>
<p>The country names in the gapminder dataset are convenient for examples. Load it now and store the 142 unique country names to the object <code>countries</code>.</p>
<pre class="r"><code>library(gapminder)
countries &lt;- levels(gapminder$country)</code></pre>
</div>
<div id="characters-with-special-meaning" class="section level4">
<h4>Characters with special meaning</h4>
<p>Frequently your string tasks cannot be expressed in terms of a fixed string, but can be described in terms of a <strong>pattern</strong>. Regular expressions, aka “regexes”, are the standard way to specify these patterns. In regexes, specific characters and constructs take on special meaning in order to match multiple strings.</p>
<p>The first placeholder is the period <code>.</code>, which stands for any single character, except a newline (which by the way, is represented by <code>\n</code>). The regex <code>a.b</code> will match all countries that have an <code>a</code>, followed by any single character, followed by <code>b</code>. Yes, regexes are case sensitive.</p>
<pre class="r"><code>str_subset(countries, &quot;i.a&quot;)
#&gt;  [1] &quot;Argentina&quot;                &quot;Bosnia and Herzegovina&quot;  
#&gt;  [3] &quot;Burkina Faso&quot;             &quot;Central African Republic&quot;
#&gt;  [5] &quot;China&quot;                    &quot;Costa Rica&quot;              
#&gt;  [7] &quot;Dominican Republic&quot;       &quot;Hong Kong, China&quot;        
#&gt;  [9] &quot;Jamaica&quot;                  &quot;Mauritania&quot;              
#&gt; [11] &quot;Nicaragua&quot;                &quot;South Africa&quot;            
#&gt; [13] &quot;Swaziland&quot;                &quot;Taiwan&quot;                  
#&gt; [15] &quot;Thailand&quot;                 &quot;Trinidad and Tobago&quot;</code></pre>
<p>Notice that <code>i.a</code> matches “ina”, “ica”, “ita”, and more.</p>
<p><strong>Anchors</strong> can be included to express where the expression must occur within the string. The <code>^</code> indicates the beginning of string and <code>$</code> indicates the end.</p>
<p>Note how the regex <code>i.a$</code> matches many fewer countries than <code>i.a</code> alone. Likewise, more fruits match <code>d</code> in <code>my_fruit</code> than <code>^d</code>, which requires “d” at string start.</p>
<pre class="r"><code>str_subset(countries, &quot;i.a$&quot;)
#&gt; [1] &quot;Argentina&quot;              &quot;Bosnia and Herzegovina&quot;
#&gt; [3] &quot;China&quot;                  &quot;Costa Rica&quot;            
#&gt; [5] &quot;Hong Kong, China&quot;       &quot;Jamaica&quot;               
#&gt; [7] &quot;South Africa&quot;
str_subset(my_fruit, &quot;d&quot;)
#&gt; [1] &quot;breadfruit&quot;  &quot;dragonfruit&quot;
str_subset(my_fruit, &quot;^d&quot;)
#&gt; [1] &quot;dragonfruit&quot;</code></pre>
<p>The sequence <code>\b</code> indicates a <strong>word boundary</strong> and <code>\B</code> indicates NOT a word boundary. This is our first encounter with something called “escaping” and right now I just want you at accept that we need to prepend a second backslash to use these sequences in regexes in R. We’ll come back to this tedious point later.</p>
<pre class="r"><code>str_subset(fruit, &quot;melon&quot;)
#&gt; [1] &quot;canary melon&quot; &quot;rock melon&quot;   &quot;watermelon&quot;
str_subset(fruit, &quot;\\bmelon&quot;)
#&gt; [1] &quot;canary melon&quot; &quot;rock melon&quot;
str_subset(fruit, &quot;\\Bmelon&quot;)
#&gt; [1] &quot;watermelon&quot;</code></pre>
</div>
<div id="character-classes" class="section level4">
<h4>Character classes</h4>
<p>Characters can be specified via classes. You can make them explicitly “by hand” or use some pre-existing ones. The <a href="block022_regular-expression.html">2014 STAT 545 regex lesson</a> has a good list of character classes. Character classes are often given inside square brackets, <code>[]</code> but a few come up so often that we have “shorthand”, such as <code>\d</code> for a single digit, or a POSIX class (examples below).</p>
<p>Here we match <code>ia</code> at the end of the country name, preceded by one of the characters in the class. Or, in the negated class, preceded by anything but one of those characters.</p>
<pre class="r"><code>## make a class &quot;by hand&quot;
str_subset(countries, &quot;[nls]ia$&quot;)
#&gt;  [1] &quot;Albania&quot;    &quot;Australia&quot;  &quot;Indonesia&quot;  &quot;Malaysia&quot;   &quot;Mauritania&quot;
#&gt;  [6] &quot;Mongolia&quot;   &quot;Romania&quot;    &quot;Slovenia&quot;   &quot;Somalia&quot;    &quot;Tanzania&quot;  
#&gt; [11] &quot;Tunisia&quot;
## use ^ to negate the class
str_subset(countries, &quot;[^nls]ia$&quot;)
#&gt;  [1] &quot;Algeria&quot;      &quot;Austria&quot;      &quot;Bolivia&quot;      &quot;Bulgaria&quot;    
#&gt;  [5] &quot;Cambodia&quot;     &quot;Colombia&quot;     &quot;Croatia&quot;      &quot;Ethiopia&quot;    
#&gt;  [9] &quot;Gambia&quot;       &quot;India&quot;        &quot;Liberia&quot;      &quot;Namibia&quot;     
#&gt; [13] &quot;Nigeria&quot;      &quot;Saudi Arabia&quot; &quot;Serbia&quot;       &quot;Syria&quot;       
#&gt; [17] &quot;Zambia&quot;</code></pre>
<p>Here we revisit splitting <code>my_fruit</code> with two more general ways to match whitespace: the <code>\s</code> shorthand and the POSIX class <code>[:space:]</code>. Notice that we must prepend an extra backslash <code>\</code> to escape <code>\s</code> and the POSIX class has to be surrounded by two sets of square brackets.</p>
<pre class="r"><code>## remember this?
# str_split_fixed(fruit, &quot; &quot;, 2)
## alternatives
str_split_fixed(my_fruit, &quot;\\s&quot;, 2)
#&gt;      [,1]           [,2]   
#&gt; [1,] &quot;breadfruit&quot;   &quot;&quot;     
#&gt; [2,] &quot;dragonfruit&quot;  &quot;&quot;     
#&gt; [3,] &quot;grapefruit&quot;   &quot;&quot;     
#&gt; [4,] &quot;jackfruit&quot;    &quot;&quot;     
#&gt; [5,] &quot;kiwi&quot;         &quot;fruit&quot;
#&gt; [6,] &quot;passionfruit&quot; &quot;&quot;     
#&gt; [7,] &quot;star&quot;         &quot;fruit&quot;
#&gt; [8,] &quot;ugli&quot;         &quot;fruit&quot;
str_split_fixed(my_fruit, &quot;[[:space:]]&quot;, 2)
#&gt;      [,1]           [,2]   
#&gt; [1,] &quot;breadfruit&quot;   &quot;&quot;     
#&gt; [2,] &quot;dragonfruit&quot;  &quot;&quot;     
#&gt; [3,] &quot;grapefruit&quot;   &quot;&quot;     
#&gt; [4,] &quot;jackfruit&quot;    &quot;&quot;     
#&gt; [5,] &quot;kiwi&quot;         &quot;fruit&quot;
#&gt; [6,] &quot;passionfruit&quot; &quot;&quot;     
#&gt; [7,] &quot;star&quot;         &quot;fruit&quot;
#&gt; [8,] &quot;ugli&quot;         &quot;fruit&quot;</code></pre>
<p>Let’s see the country names that contain punctuation.</p>
<pre class="r"><code>str_subset(countries, &quot;[[:punct:]]&quot;)
#&gt; [1] &quot;Congo, Dem. Rep.&quot; &quot;Congo, Rep.&quot;      &quot;Cote d&#39;Ivoire&quot;   
#&gt; [4] &quot;Guinea-Bissau&quot;    &quot;Hong Kong, China&quot; &quot;Korea, Dem. Rep.&quot;
#&gt; [7] &quot;Korea, Rep.&quot;      &quot;Yemen, Rep.&quot;</code></pre>
</div>
<div id="quantifiers" class="section level4">
<h4>Quantifiers</h4>
<p>You can decorate characters (and other constructs, like shorthand and classes) with information about how many characters they are allowed to match.</p>
<table>
<thead>
<tr class="header">
<th>quantifier</th>
<th>meaning</th>
<th>quantifier</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>*</td>
<td>0 or more</td>
<td>{n}</td>
<td>exactly n</td>
</tr>
<tr class="even">
<td>+</td>
<td>1 or more</td>
<td>{n,}</td>
<td>at least n</td>
</tr>
<tr class="odd">
<td>?</td>
<td>0 or 1</td>
<td>{,m}</td>
<td>at most m</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>{n,m}</td>
<td>between n and m, inclusive</td>
</tr>
</tbody>
</table>
<p>Explore these by inspecting matches for <code>l</code> followed by a <code>e</code>, allowing for various numbers of characters in between.</p>
<p><code>l.*e</code> will match strings with 0 or more characters in between, i.e. any string with an <code>l</code> eventually followed by an <code>e</code>.</p>
<pre class="r"><code>(matches &lt;- str_subset(fruit, &quot;l.*e&quot;))
#&gt;  [1] &quot;apple&quot;             &quot;bell pepper&quot;       &quot;bilberry&quot;         
#&gt;  [4] &quot;blackberry&quot;        &quot;blood orange&quot;      &quot;blueberry&quot;        
#&gt;  [7] &quot;cantaloupe&quot;        &quot;chili pepper&quot;      &quot;clementine&quot;       
#&gt; [10] &quot;cloudberry&quot;        &quot;elderberry&quot;        &quot;huckleberry&quot;      
#&gt; [13] &quot;lemon&quot;             &quot;lime&quot;              &quot;lychee&quot;           
#&gt; [16] &quot;mulberry&quot;          &quot;olive&quot;             &quot;pineapple&quot;        
#&gt; [19] &quot;purple mangosteen&quot; &quot;salal berry&quot;</code></pre>
<p>Change the quantifier to <code>+</code> to require at least one intervening character. The strings that no longer match: all have a literal <code>le</code> with no preceding <code>l</code> and no following <code>e</code>.</p>
<pre class="r"><code>list(match = intersect(matches, str_subset(fruit, &quot;l.+e&quot;)),
     no_match = setdiff(matches, str_subset(fruit, &quot;l.+e&quot;)))
#&gt; $match
#&gt;  [1] &quot;bell pepper&quot;       &quot;bilberry&quot;          &quot;blackberry&quot;       
#&gt;  [4] &quot;blood orange&quot;      &quot;blueberry&quot;         &quot;cantaloupe&quot;       
#&gt;  [7] &quot;chili pepper&quot;      &quot;clementine&quot;        &quot;cloudberry&quot;       
#&gt; [10] &quot;elderberry&quot;        &quot;huckleberry&quot;       &quot;lime&quot;             
#&gt; [13] &quot;lychee&quot;            &quot;mulberry&quot;          &quot;olive&quot;            
#&gt; [16] &quot;purple mangosteen&quot; &quot;salal berry&quot;      
#&gt; 
#&gt; $no_match
#&gt; [1] &quot;apple&quot;     &quot;lemon&quot;     &quot;pineapple&quot;</code></pre>
<p>Change the quantifier to <code>?</code> to require at most one intervening character. In the strings that no longer match, the shortest gap between <code>l</code> and following <code>e</code> is at least two characters.</p>
<pre class="r"><code>list(match = intersect(matches, str_subset(fruit, &quot;l.?e&quot;)),
     no_match = setdiff(matches, str_subset(fruit, &quot;l.?e&quot;)))
#&gt; $match
#&gt;  [1] &quot;apple&quot;             &quot;bilberry&quot;          &quot;blueberry&quot;        
#&gt;  [4] &quot;clementine&quot;        &quot;elderberry&quot;        &quot;huckleberry&quot;      
#&gt;  [7] &quot;lemon&quot;             &quot;mulberry&quot;          &quot;pineapple&quot;        
#&gt; [10] &quot;purple mangosteen&quot;
#&gt; 
#&gt; $no_match
#&gt;  [1] &quot;bell pepper&quot;  &quot;blackberry&quot;   &quot;blood orange&quot; &quot;cantaloupe&quot;  
#&gt;  [5] &quot;chili pepper&quot; &quot;cloudberry&quot;   &quot;lime&quot;         &quot;lychee&quot;      
#&gt;  [9] &quot;olive&quot;        &quot;salal berry&quot;</code></pre>
<p>Finally, we remove the quantifier and allow for no intervening characters. The strings that no longer match lack a literal <code>le</code>.</p>
<pre class="r"><code>list(match = intersect(matches, str_subset(fruit, &quot;le&quot;)),
     no_match = setdiff(matches, str_subset(fruit, &quot;le&quot;)))
#&gt; $match
#&gt; [1] &quot;apple&quot;             &quot;clementine&quot;        &quot;huckleberry&quot;      
#&gt; [4] &quot;lemon&quot;             &quot;pineapple&quot;         &quot;purple mangosteen&quot;
#&gt; 
#&gt; $no_match
#&gt;  [1] &quot;bell pepper&quot;  &quot;bilberry&quot;     &quot;blackberry&quot;   &quot;blood orange&quot;
#&gt;  [5] &quot;blueberry&quot;    &quot;cantaloupe&quot;   &quot;chili pepper&quot; &quot;cloudberry&quot;  
#&gt;  [9] &quot;elderberry&quot;   &quot;lime&quot;         &quot;lychee&quot;       &quot;mulberry&quot;    
#&gt; [13] &quot;olive&quot;        &quot;salal berry&quot;</code></pre>
</div>
<div id="escaping" class="section level4">
<h4>Escaping</h4>
<p><em>come back here</em></p>
<p><a href="block022_regular-expression.html">2014 STAT 545 lesson an regular expressions</a> has good coverage of characters with special meaning in regex and escape sequences.</p>
<p>Many characters take on special meaning inside regexes. Of course this implies you have to do extra work to include those actual characters in your pattern. This is called <em>escaping</em> and requires prepending a backslash. something called <em>escaping</em> and boils down to “add more backslashes”.</p>
</div>
<div id="backreferences" class="section level4">
<h4>Backreferences</h4>
<p><em>come back here</em></p>
</div>
</div>

<div class="footer">
This work is licensed under the  <a href="http://creativecommons.org/licenses/by-nc/3.0/">CC BY-NC 3.0 Creative Commons License</a>.
</div>



</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
